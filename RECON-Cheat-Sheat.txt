RECON Cheat-Sheat

0)TOP Fuzz lists
____________________________________________________
https://wordlists.assetnote.io/
https://github.com/orwagodfather/WordList/blob/main/SQL.txt
https://github.com/six2dez/OneListForAll
https://github.com/nu11pointer/fuzzlists/blob/main/Fuzzing

https://github.com/missteek/cpts-quick-references?tab=readme-ov-file   - подсказки ЧЕКНУТЬ!!!!!!!!!!

https://habr.com/ru/companies/owasp/articles/352422/  - здесь ссылки на все остальные фаз листы

cewl https://example.com/* -w list.txt  - создать кастомный вордлист
____________________________________________________
• прочитать документацию target- в самом начале обязательно


1) сабдомены:
____________________________________________________
• subfinder -d https://example.com/
• sublist3r -d example.com - самый популярный посиковик сабдоменов
• https://crt.sh/?q=    - отличный поиск поддоменов
  Terminal:
  export TARGET="example.com"
  curl -s "https://crt.sh/?q=${TARGET}&output=json" | jq -r '.[] | "\(.name_value)\n\(.common_name)"' | sort -u > "/home/kali/Desktop/Document/ffuz_txt/${TARGET}_crt.sh.txt"

• amass enum -passive -d example.com  - самый лучший на мой взгляд!!!
• assetfinder example.com  
• ffuf -w /home/kali/Desktop/Document/ffuz_txt/subdomains-top1million-110000.txt -u http://example.com -H "Host: FUZZ.example.com" -mc 200,302 -fl 518
____________________________________________________
• cat /home/kali/Desktop/Subdomens/Subdomen1 |anew /home/kali/Desktop/Subdomens/Subdomen2 - anew сортирует  и добовляет файлы которых различаються в Subdomen1 
• subzy run --targets /home/kali/Desktop/Subdomens/Subdomen2 - захват поддамена 
• paramspider -l /home/kali/Desktop/Subdomens/Subdomen2 - ищем рабочие url

____________________________________________________
Фаззинг сабдоменов VHOST - очень важно (отличаеться от обычных сабдоменов)

• ffuf -w /home/kali/Desktop/Document/ffuz_txt/subdomains-top1million-110000.txt -u https://www.example.com -H 'Host: FUZZ.example.com' -fs 0 (fs не обязательно)



2)Технологии и поиск портов и сервисов
____________________________________________________
• (kali㉿kali)-[~]
   └─$ dig www.example.com
на данном ip должен работать DNS протокол  по типу (53/tcp   open  domain    syn-ack ISC BIND 9.16.48 (Ubuntu Linux)) и берем ip на котором есть этот порт
   Example:  dig @10.124.1.240 edu.stf MX




• https://www.whois.com/
• https://www.bigdomaindata.com/whois-history/ - полезно если сейчас стоит новый блокировшик то можно посмотреть старую инфу
• https://w3techs.com/sites/info/example.com
• https://builtwith.com/ - смотрим что использует web-преложение
• https://www.exploit-db.com/google-hacking-database, https://telegra.ph/5-Google-Dorks-kotorye-dolzhen-znat-kazhdyj-09-06  - проверяем на гугл дорки
•https://pentest-tools.com/information-gathering/google-hacking - сайт для поиска дорков
	https://telegra.ph/Nahodim-utekshie-v-set-konfidencialnye-dokument-03-30-2 - сайт про то как  работают дорки

•https://sitereport.netcraft.com/?url= - еще раз смотрим что использует web-преложение и обязательно выписываем
•Shodan - hostname:example.com - смотрим инфу с Shodan

• whatruns and wappalyzer
• nmap -v -A example.com
  nmap -iL hosts.txt -Pn --min-rate 5000 --max-retries 1 --max-scan-delay 20 мс -T4 --top-ports 1000 --exclude-ports 22,80,443,53,5060,8080 --open -oX nmap.xml
  sudo  nmap -sS -sV -O -A -T4 --script=vuln -p- --open -oA comprehensive_scan example.com
  nmap -Pn -sC -sV -oA tcp -p- -T4 -vvvvv --reason <ip adress> - разведка

  sudo nmap  -p- -sV -Pn -sC -v -T2  -D RND:10 10.124.1.233  - лучшая разведка nmap


  https://infosecwriteups.com/port-scanning-for-bug-bounties-b28b23ce9fbf
____________________________________________________


3)Url find
____________________________________________________
• )kali㉿kali)-[~/Desktop]
   └─$ cat wayback/domain.txt | waybackurls | tee -a wayback/domain_out.txt  где в wayback/domain.txt находяться домены а в wayback/domain_out.txt возможные катологи этих url и конечные    точки
• cat wayback/domain_out.txt | uro | tee -a wayback/domain_out_uro.txt
    - проверить какие url рабочие 
• (kali㉿kali)-[~/Desktop]
└─$ cat wayback/domain_out_uro.txt | httpx | tee -a wayback/domain_out_httpx_uro.txt
    -  убирает url c одинаковыми значениями в параметрах

	что бы не тратить много времени открываем все url через plugin open-multiple-urls
• просканить домен/ip на наличие дополнительных портов - обязательно
• сканим дериктории: feroxbuster --url https://www.example.com --depth 2  --wordlist /home/kali/Desktop/Document/ffuz_txt/bigest_direcroty_fuzz --status-codes 200,500,401,302,403
    --rate-limit 8
 https://codeby.net/threads/ehffektivnyj-fazzing-feroxbuster.81022/
• ┌──(kali㉿kali)-[~/Downloads]
  └─$ gospider -s https://example.com/  -c 10 -d 5 --blacklist ".(jpg|jpeg|gif|css|tif|tiff|png|ttf|woff|woff2|ico|pdf|svg|txt)" --other-source | grep -e "code-200" | awk '{print $5}' | grep "=" | qsreplace -a | dalfox pipe -o result.txt
ищет xss по всему сайту если нет ограничения на количество пакетов

• ffuf -w /opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://SERVER_IP:PORT/blog/indexFUZZ  - фазим index. на разные расшерения и потом мы нашли php допустим
  https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt - список для фаззинга
  ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/blog/FUZZ.php - не уверен что работает


• Ещё и полезного, что недавно для себя открыл .Открываем консольку и запускаем скрипт  -  выодит дериктории найденые в JS .

javascript:(function(){var scripts=document.getElementsByTagName("script"),regex=/(?<=(\"|\'|\`))\/[a-zA-Z0-9_?&=\/\-\#\.]*(?=(\"|\'|\`))/g;const results=new Set;for(var i=0;i<scripts.length;i++){var t=scripts[i].src;""!=t&&fetch(t).then(function(t){return t.text()}).then(function(t){var e=t.matchAll(regex);for(let r of e)results.add(r[0])}).catch(function(t){console.log("An error occurred: ",t)})}var pageContent=document.documentElement.outerHTML,matches=pageContent.matchAll(regex);for(const match of matches)results.add(match[0]);function writeResults(){results.forEach(function(t){document.write(t+"<br>")})}setTimeout(writeResults,3e3);})();
  

____________________________________________________



4)Vulnerability Scans
____________________________________________________

• nikto -h https://example.com - сканим на ошибки web-преложение
  nikto -h example.com -ssl           - если есть ssl покажет много полезной информации ,также никто очень палиться и может быть в последствии забанен
• wapiti -v2 -u https://example.com - еще раз сканим и смотрим open <...>

• wpscan --url https://example.com -e ap --plugins-detection passive --ignore-main-redirect  -сканит сайт на плагины и смотрит их уязвимости только для Wordpress!!!               
	(--plugins-detection agressive)
• wpscan --url http://blog.example.com --enumerate --api-token Kffr4fdJzy9qVcTk<SNIP>
• nuclei -u https://example.com -H "Cookie: cookie_value" -rl 3 -c 2 -as -o /home/kali/Desktop/Document/Nuclei_input   -сканит сайт 
	-rl       -количество запросов в секунду
	-c        -количество одновременно используемых шаблонов
	-as       -автомотически подбирать шаблоны импользуя wapalayzer
	-o        -записывает рузультат в файл
	-H        -используеться что бы добавить заголовок (не только куки)
• Nessus- https://kali:8834/#/scans/  
	sudo systemctl status nessusd
	sudo systemctl start nessusd 
____________________________________________________


5)Additionally
____________________________________________________
• https://github.com/xnl-h4ck3r/xnLinkFinder  36:37 ищет ссылки в js но лучше использовать Burp extension "JsLinkFinder"
• RetireJS/retire.js -  ищет устаревшие фреймворки		 https://www.youtube.com/watchv=FqnSAa2KmBI&t1510s&ab_channel=HackerOne	  
• https://github.com/bugcrowd/HUNT/blob/master/Burp/conf/issues.json  39:20 	
• ./reconftw.sh -d target.com -a   - сканит почти все что возможно (но мне не понравилось)     https://github.com/six2dez/reconftw
• https://csp-evaluator.withgoogle.com/ - CSP XSS Bypass показывает какие уязвимости есть в CSP 

Идентификация исходных файлов карт
Исходные файлы карт обычно загружаются при открытии средств разработки. Тестировщики также могут найти исходные файлы карт, добавив расширение ".map" после расширения каждого внешнего файла JavaScript. Например, если тестировщик видит файл, он может проверить наличие его исходного файла карты, посетив    ./static/js/main.chunk.js    -    ./static/js/main.chunk.js.map
____________________________________________________

6)API Recon
____________________________________________________

Информация взята с https://readmedium.com/5-methods-i-use-to-discover-apis-6d646baa3ffb
---------------- 
----------------
#1 — API-документация
Но иногда документация общедоступна без какой-либо причины, кроме чрезмерной демонстрации.

В любом случае, это очень полезная информация. Она не только отображает конечные точки API основного приложения, но и объясняет, как функционирует сам API :

• Какие типы данных ожидает получить конкретная конечная точка (целое число/строка, JSON/XML, POST/PUT/GET и т. д.)
• Требуемые заголовки для отправки
• Ответ, который мы должны получить на запрос
• Уровень аутентификации, необходимый для конкретной конечной точки

В случае, если у нашей цели нет документации API, мы можем создать собственную документацию для приложения без особых усилий . Подробнее об этом читайте в этой статье: Как создать мошеннические документы API для цели, если их нет . https://danaepp.com/how-to-craft-rogue-api-docs-for-a-target-when-they-dont-exist  - Очень интересная/полезная статья
----------------
----------------
#2 — API OSINT-исследование

• Разработчики постоянно работают над API и, вероятно, используют различные инструменты для создания, тестирования и документирования различных версий API.
• Вполне вероятно, что существуют более старые версии API приложения, которые мы сможем найти, и, возможно, они менее безопасны, чем текущая версия, находящаяся в эксплуатации!

Давайте поговорим о нескольких инструментах OSINT, которые мы можем легко использовать и довольно быстро получать результаты.

Google Доркинг:
Быстрый поиск Google dorking может дать нам:

• Субдомены цели, связанные с API
• Страница документации API цели
• Конечные точки API — старые и текущие версии

site:target.com inurl:”/v1"
site:target.com inurl:”/api"
site:target.com inurl:”/graphql"
site:target.com intitle:”api*”

WaybackMachine:
Одним из лучших инструментов для обнаружения конечных точек API и сбора некоторых секретов одновременно является WaybackMachine .
Просто выполнив поиск по домену компании и отфильтровав по слову «api», мы получили несколько конечных точек API, содержащих даже GraphQL.

Используя найденные учетные данные, я иногда могу тестировать конечные точки API после аутентификации с различными разрешениями пользователя .
Кроме того, рекомендуется интегрировать GAU или Waymore в вашу систему автоматизации разведки для извлечения большего количества конечных точек API .

Postman(Что то по типу Burp для API):

Postman доступен как SaaS-приложение на postman.com и позволяет разработчикам делиться проектами, чтобы облегчить работу команд. Проект postman, также известный как коллекция postman, обычно считается закрытым. Но во многих случаях вы увидите, что коллекции являются публично открытыми. В коллекциях есть много деталей, таких как параметры, заголовки, данные тела, переменные среды и токены авторизации .


GitHub:
С несколькими ключевыми словами мы максимизируем наши шансы найти конечные точки API и подробное объяснение того, как они работают.

Some common keywords for API:

/v1
/api
apikey
api_key
apidocs
api_secret
x-api-key
/graphql

Как и в случае с Postman и WaybackMachine, в GitHub у нас также есть хороший шанс найти некоторые секреты и учетные данные, которые могут оказаться полезными на следующих этапах взаимодействия.
----------------
----------------
#3 — HTML и Javascript приложения
В FireFox, если мы откроем DevTools (F12) и откроем вкладку Debugger (или вкладку Sources в Chrome), мы увидим адрес нашей цели и маленькую стрелку, указывающую вниз. Нажав на маленькую стрелку, мы получим ресурсы frontend, включая файл Javascript.

осле нахождения файлов Javascript мы обычно получаем кусок минифицированного кода, без новых строк и пробелов
В этом случае мы можем использовать JS-претификатор, например, этот . https://beautifier.io/

После этого просто скопируйте код в свой редактор кода, например VSCode или Sublime, и начните поиск запросов API.

Ищите ключевые слова, такие как API, v1, v2, user и другие общие слова, связанные с API. Еще одно, что нужно сделать, это найти методы HTTP, которые указывают на отправку запроса на бэкэнд .

Также, если нам нужен автоматизированный инструмент, мы можем использовать Katana

Хорошей рекомендацией будет использовать Katana и просмотреть вывод, а затем запустить его снова с несколькими дополнительными настройками для конкретного веб-приложения .

Просматривая HTML и Javascript приложения, мы можем сопоставить большинство вызовов API и даже раскрыть теневые API. https://www.cloudflare.com/learning/security/api/what-is-shadow-api/

Из-за малой уязвимости теневых API они, как правило, имеют более высокий потенциал уязвимости , поскольку их тестируют очень редко.
----------------
----------------
#4 — Активное сканирование — Фаззинг

Когда дело доходит до фаззинга API, необходимо учитывать два важных момента:

• Фаззеры/сканеры: по сути, это инструмент, который отправляет HTTP-запросы и фильтрует ответы, чтобы мы могли заранее определить, что именно будет нам интересно.
• Списки слов: контент, который мы фаззим. Хороший список слов — это разница между поиском уязвимости для простого запуска общих слов и пустой тратой времени .

В наши дни существует множество инструментов, которые отлично справляются с обнаружением API посредством фаззинга. Для простых запросов GET со списком конечных точек мы всегда можем использовать такие инструменты, как Burp Intruder, ffuf, GoBuster, Kiterunner и даже создать свой собственный фаззер. В большинстве случаев я нахожу ffuf и Kiterunner(https://github.com/assetnote/kiterunner) отличными инструментами не только с точки зрения скорости, но и полезных функций, которые они предоставляют, таких как фильтрация по размеру, коду состояния, словам и т. д. Конкретно о Kiterunner, объединяющем соответствующие списки из Assetnote, этот инструмент отлично подходит для современных веб-приложений (NodeJS, Flask, Rails и т. д.) .

С помощью одной команды вы можете получить очень хорошее представление об API-картине вашей цели:

./kr scan https://target.com -w ~/wordlists/routes-large.json

Кроме того, кроме конечных точек API мы также должны обнаружить, какие параметры принимаются бэкендом . Конечно, есть параметры «по умолчанию» легитимных запросов, но что, если есть также «теневые параметры»? Возможно, мы сможем найти уязвимость массового назначения , которую у нас нет другого способа найти, кроме как нечетко определить цель. Для этой задачи я вижу Arjun как один из лучших инструментов .

Arjun — это инструмент Python, который просто отправляет запросы GET на заданный URL с большим количеством различных параметров. В конце инструмент предоставит нам список допустимых параметров для дальнейшего тестирования. Я напишу больше об использовании Arjun в будущей статье о взломе API.

Списки слов:
Использование правильного списка слов — ключ к успешному тестированию API на проникновение. Есть несколько отличных ресурсов для этой миссии: SecLists , Assetnote , FuzzDB и другие.

Ленивые хакеры будут использовать общие списки слов , которые просто содержат огромное количество слов, но без какой-либо конкретной цели. Профессионалы всегда будут пытаться получить более конкретные списки слов в соответствии с целью . Например, если мы знаем, что наша цель — веб-приложение по прокату автомобилей, основанное на Django в качестве бэкэнда, мы можем объединить общий список слов для Django с пользовательским списком слов для проката автомобилей. Для первого списка слов мы можем использовать assetnote

А во-вторых, мы можем попросить ChatGPT сгенерировать список общих конечных точек API для аренды автомобилей.
----------------
----------------
#5 — Мобильный

В этом случае это может означать, что API, существующие в Javascript веб-приложения, не будут совпадать с конечными точками API, существующими в APK-файле .
можем использовать инструменты статического анализа, такие как JADX и MobSF, для получения некоторых жестко запрограммированных конечных точек API, которые находятся в APK .

Используя вышеупомянутые методы, мы тщательно построим картину приложения и получим отличную основу для взлома API различных приложений.
____________________________________________________

7)Deobfuscation code
____________________________________________________
• https://obfuscator.io/ - сайт для obfuscation code
• https://jsfuck.com/ - сайт для obfuscation code в виде [+[]]])[+!+[]
• https://jsconsole.com/ - онлайн js консоль
• http://www.jsnice.org/ - сайт для Deobfuscation code (делает код более четабельным) 


• Decoding:
  echo aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K | base64 -d                         - base64 decode
  echo 68747470733a2f2f7777772e6861636b746865626f782e65752f0a | xxd -p -r       - hex decode

• https://www.boxentriq.com/code-breaking/cipher-identifier - определит какой шифр испрользуеться

• hashcat -a 3 -m 16500 /home/kali/Desktop/Document/ffuz_txt/jwt.txt ?a?a?a?a?a?a?a -i --increment-min=4   - jwt secret finder (можно не только jwt(перебор всего))

https://jwt.io/


----------------------------------------------
Чтение JavaScript

Если используеться React и указан файл .map для javascript.

Распаковка исходного кода приложения
Существует множество инструментов для распаковки исходного кода приложения React. Один из них упомянут в сообщении блога выше.
https://github.com/rarecoil/unwebpack-sourcemap?source=post_page-----8b132f81174b--------------------------------

Но лично я использовал инструмент, созданный @spaceraccoon, который называется webpack-exploder.
Вы можете распаковать файл .map, используя пользовательский интерфейс, размещенный в сети самим spaceracoon здесь: https://spaceraccoon.github.io/webpack-exploder/

Используем этот инструмент и получаем исходный код в котором может быть много интересного 

--------------

Небольшой инструмент, который я создал, предназначен как раз для решения этой проблемы, называется BitMapper, он добавляет микро sourceMappingURL в каждый файл javascript, который он видит, давая нам возможность заставить браузер декодировать скрытые файлы карт.

https://github.com/BitTheByte/BitMapper?source=post_page-----dd08ed34b5a8--------------------------------

--------------
Если есть Meteor.js

https://bitthebyte.medium.com/javascript-for-bug-bounty-hunters-part-3-3b987f24ab27




________________________________________________________________________________________________________________________
сайты для OSINT

Вот список из 30 поисковых систем по кибербезопасности (Могут быть вирусы):

если сервер NGnix-https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies

1. [Dehased](https://dehased.com/) — просмотр утекших учетных данных.  (virus скорее всего)
2. [SecurityTrails](https://securitytrails.com/) — обширные данные DNS.
3. [DorkSearch](https://dorksearch.net/) — Действительно быстрый поиск Google.
4. [ExploitDB](https://www.exploit-db.com/) — Архив различных эксплойтов.
5. [ZoomEye](https://www.zoomeye.org/) — Сбор информации о целях.
6. [Pulsedive](https://pulsedive.com/) — поиск информации об угрозах.
7. [GrayHatWarefare](https://buckets.grayhatwarfare.com/) — поиск в общедоступных корзинах S3.
8. [PolySwarm](https://polyswarm.network/) — сканируйте файлы и URL-адреса на наличие угроз.
9. [Fofa](https://fofa.so/) — поиск различных сведений об угрозах.
10. [LeakIX](https://leakix.net/) — поиск общедоступной информации.
11. [DNSDumpster](https://dnsdumpster.com/) — быстрый поиск записей DNS.
12. [FullHunt](https://www.fullhunt.io/) — поиск и обнаружение поверхностей атак.
13. [AlienVault](https://www.alienvault.com/) — обширная информация об угрозах.
14. [ONYPHE](https://www.onyphe.io/) — собирает данные разведки о киберугрозах.
15. [Grep App](https://grep.app/) — поиск по полумиллиону репозиториев Git.
16. [URL Scan](https://urlscan.io/) — Бесплатный сервис для сканирования и анализа веб-сайтов.
17. [Vulners](https://vulners.com/) — Поиск уязвимостей в большой базе данных.
18. [WayBackMachine](https://archive.org/web/) — просмотр содержимого удаленных веб-сайтов.
19. [Shodan](https://www.shodan.io/) — Поиск устройств, подключенных к Интернету.
20. [Netlas](https://netlas.io/) — поиск и мониторинг подключенных к Интернету ресурсов.
21. [CRT.sh](https://crt.sh/) — поиск сертификатов, зарегистрированных CT.
22. [Wigle](https://wigle.net/) — База данных беспроводных сетей со статистикой.
23. [PublicWWW](https://publicwww.com/) — Маркетинговые и партнерские маркетинговые исследования.
24. [Binary Edge](https://www.binaryedge.io/) — сканирует Интернет на предмет угроз.
25. [GreyNoise](https://greynoise.io/) — Поиск устройств, подключенных к Интернету.
26. [Hunter](https://hunter.io/) — поиск адресов электронной почты, принадлежащих веб-сайту.
27. [Censys](https://censys.io/) — Оценка поверхности атаки для устройств, подключенных к Интернету.
28. [IntelligenceX](https://intelx.io/) — поиск в Tor, I2P, утечки данных, домены и электронная почта.
29. [Packet Storm Security](https://packetstormsecurity.com/) — просмотрите последние уязвимости и эксплойты.
30. [SearchCode](https://searchcode.com/) — Найдите 75 миллиардов строк кода из 40 миллионов проектов.

Обратите внимание: хотя эти поисковые системы предоставляют полезную информацию о кибербезопасности, важно использовать их ответственно и этично.
________________________________________________________________________________________________________________________
Большинство приложений используют ту или иную схему именования своего 
содержимого и функций. Опираясь на ресурсы, уже идентифицированные в 
приложении, можно точно настроить автоматическое перебор, чтобы повысить 
вероятность обнаружения дальнейшего скрытого контента
Обратите внимание, что в приложении EIS все ресурсы в /auth начинаются с заглавной буквы. тоесть надо настроить перебор списка деректорий специально под сайт

Просмотрите эти списки, чтобы определить используемые схемы именования. Например, если есть
страницы с именами AddDocument.jsp и ViewDocument.jsp, также могут существовать страницы с
именами EditDocument.jsp и RemoveDocument.jsp.

Часто вы можете получить представление о привычках разработчиков в области именования,
просто прочитав несколько примеров. Например, в зависимости от своего личного стиля
разработчики могут быть многословными (AddANewUser.asp), краткими (AddUser.asp).
использовать сокращения (AddUsr.asp) или даже более загадочными (AddU.asp). Понимание
используемых стилей именования может помочь вам угадать точные названия контента, который
вы еще не определили.

3. Иногда схема именования, используемая для различного контента, использует
идентификаторы, такие как числа и
даты, которые могут
облегчить определение скрытого контента.
Чаще всего это встречается в именах статических ресурсов, а не в динамических скриптах.
Например, если веб-сайт компании ссылается на AnnualReport2009.pdf и AnnualReport2010.pdf,
это должен быть небольшой шаг к определению того, как будет называться следующий отчет.
Несколько невероятно, но были печально известные случаи, когда компании размещали
файлы, содержащие финансовые отчеты, на своих веб-серверах до того, как они были публично
объявлены, только для того, чтобы коварные журналисты обнаруживали их на основе схемы
именования, использовавшейся в предыдущие годы.
